from typing import Optional

from models import ProductFields
from pydantic import BaseModel, constr
from sqlalchemy import select
from sqlalchemy.orm import Session


class ProductField(BaseModel):
    id: Optional[int]
    product_id: int
    field_id: int

    class Config:
        orm_mode = True

    @classmethod
    async def add(cls, product_field: 'ProductField', db: Session) -> 'ProductField':
        """
        Add a product_field to the database.
        The product_field's id is auto generated by the database.
        The id is suppressed without warning.
        """
        values = product_field.dict()
        values.pop('id')
        
        db.add(ProductFields(**values))
        db.commit()
        
        return product_field

    @classmethod
    async def get(cls, id: int, db: Session) -> Optional['product_field']:
        """Get a product_field from the database from its id."""
        product_field = db.query(ProductFields).filter(ProductFields.id == id).first()
        return product_field
    
    @classmethod
    async def get_by_product_id(cls, product_id: int, db: Session) -> Optional['product_field']:
        """Get a product_field from the database from its product_id."""
        product_field = db.query(ProductFields).filter(ProductFields.product_id == product_id).all()
        return product_field
    
    @classmethod
    async def get_by_field_id(cls, field_id: int, db: Session) -> Optional['product_field']:
        """Get a product_field from the database from its field_id."""
        product_field = db.query(ProductFields).filter(ProductFields.field_id == field_id).all()
        return product_field

    @classmethod
    async def get_all(cls, db: Session) -> list['product_field']:
        """Return a list of all ProductFields from the database."""
        return db.query(ProductFields).all()

    @classmethod
    async def update(cls, id: int, db: Session, **kwargs) -> Optional['product_field']:
        """Update product_fields of a product_field."""
        product_field = await cls.get(id, db)
        if product_field:
            for key, value in kwargs.items():
                setattr(product_field, key, value)
            db.commit()
        return product_field

    @classmethod
    async def delete(cls, id: int, db: Session) -> Optional['product_field']:
        """Delete a product_field and return it. Return None if the product_field does not exists."""
        product_field = await cls.get(id, db)
        if product_field:
            print("Deleting product_field")
            db.delete(product_field)
            db.commit()
        return product_field
