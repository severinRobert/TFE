from typing import Optional

from models import UserRoles
from pydantic import BaseModel, constr
from sqlalchemy import select
from sqlalchemy.orm import Session


class UserRole(BaseModel):
    id: Optional[int]
    user_id: int
    role_id: int

    class Config:
        orm_mode = True

    @classmethod
    async def add(cls, user_role: 'UserRole', db: Session) -> 'UserRole':
        """
        Add a user_role to the database.
        The user_role's id is auto generated by the database.
        The id is suppressed without warning.
        """
        values = user_role.dict()
        values.pop('id')
        
        db.add(UserRoles(**values))
        db.commit()
        
        return user_role

    @classmethod
    async def get(cls, id: int, db: Session) -> Optional['user_role']:
        """Get a user_role from the database from its id."""
        user_role = db.query(UserRoles).filter(UserRoles.id == id).first()
        return user_role
    
    @classmethod
    async def get_by_user_id(cls, user_id: int, db: Session) -> Optional['user_role']:
        """Get a user_role from the database from its user_id."""
        user_role = db.query(UserRoles).filter(UserRoles.user_id == user_id).all()
        return user_role
    
    @classmethod
    async def get_by_role_id(cls, role_id: int, db: Session) -> Optional['user_role']:
        """Get a user_role from the database from its role_id."""
        user_role = db.query(UserRoles).filter(UserRoles.role_id == role_id).all()
        return user_role
    
    @classmethod
    async def get_by_user_id_and_role_id(cls, user_id: int, role_id: int, db: Session) -> Optional['user_role']:
        """Get a user_role from the database from its role_id."""
        user_role = db.query(UserRoles).filter(UserRoles.user_id == user_id, UserRoles.role_id == role_id).first()
        return user_role

    @classmethod
    async def get_all(cls, db: Session) -> list['user_role']:
        """Return a list of all UserRoles from the database."""
        return db.query(UserRoles).all()

    @classmethod
    async def update(cls, id: int, db: Session, **kwargs) -> Optional['user_role']:
        """Update user_roles of a user_role."""
        user_role = await cls.get(id, db)
        if user_role:
            for key, value in kwargs.items():
                setattr(user_role, key, value)
            db.commit()
        return user_role

    @classmethod
    async def delete(cls, id: int, db: Session) -> Optional['user_role']:
        """Delete a user_role and return it. Return None if the user_role does not exists."""
        user_role = await cls.get(id, db)
        if user_role:
            db.delete(user_role)
            db.commit()
        return user_role
