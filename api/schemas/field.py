from typing import Optional

from models import Fields
from .product_field import ProductField
from .value_bool import ValueBool
from .value_int import ValueInt
from .value_float import ValueFloat
from .value_string import ValueString
from pydantic import BaseModel, constr
from sqlalchemy.orm import Session


class Field(BaseModel):
    id: Optional[int]
    name: constr(max_length=20)
    display_name: constr(max_length=20)
    description: Optional[constr(max_length=255)]
    is_required: bool
    is_filterable: bool
    type_id: int
    selections_groups_id: Optional[int]

    class Config:
        orm_mode = True

    @classmethod
    async def add(cls, field: 'Field', db: Session) -> 'Field':
        """
        Add a field to the database.
        The field's id is auto generated by the database.
        The id is suppressed without warning.
        """
        values = field.dict()
        values.pop('id')
        db_field = Fields(**values)
        
        db.add(db_field)
        db.commit()
        db.refresh(db_field)
        return db_field

    @classmethod
    async def get(cls, id: int, db: Session) -> Optional['field']:
        """Get a field from the database from its id."""
        field = db.query(Fields).filter(Fields.id == id).first()
        return field

    @classmethod
    async def get_by_selections_groups_id(cls, id: int, db: Session) -> Optional['field']:
        """Get a selection from the database from its selections_groups_id."""
        field = db.query(Fields).filter(Fields.selections_groups_id == id).all()
        return field

    @classmethod
    async def get_all(cls, db: Session) -> list['field']:
        """Return a list of all Fields from the database."""
        return db.query(Fields).all()

    @classmethod
    async def update(cls, id: int, field: dict, db: Session) -> Optional['field']:
        """Update fields of a field."""
        db_field = await cls.get(id, db)
        if db_field:
            for key, value in field.items():
                setattr(db_field, key, value)
            db.commit()
            db.refresh(db_field)
        return db_field

    @classmethod
    async def delete(cls, id: int, db: Session, force: bool = False) -> Optional['field']:
        """Delete a field and return it. Return None if the field does not exists."""
        # Exist check
        field = await cls.get(id, db)
        if not field:
            raise Exception("Field does not exist")

        # Dependency check
        product_fields = await ProductField.get_by_field_id(id, db)
        if product_fields and not force:
            raise Exception("Field still has product fields", product_fields)
        for product_field in product_fields:
            await ProductField.delete(product_field.id, db)

        for value in [*await ValueString.get_by_field_id(field.id, db), *await ValueInt.get_by_field_id(field.id, db), *await ValueFloat.get_by_field_id(field.id, db), *await ValueBool.get_by_field_id(field.id, db)]:
            db.delete(value)

        # Commit and delete
        db.commit()
        db.delete(field)
        db.commit()
        return field
