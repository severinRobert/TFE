from typing import Optional

from models import Fields, get_db
from pydantic import BaseModel, constr
from sqlalchemy import select
from sqlalchemy.orm import Session
from fastapi import Depends


class Field(BaseModel):
    id: Optional[int]
    name: constr(max_length=20)
    description: Optional[constr(max_length=255)]
    is_required: bool
    is_filterable: bool
    type_id: int
    selections_group_id: Optional[int]

    @classmethod
    async def add(cls, field: 'Field', db: Session = Depends(get_db)) -> 'Field':
        """
        Add a field to the database.
        The field's id is auto generated by the database.
        The id is suppressed without warning.
        """
        values = field.dict()
        values.pop('id')

        query = Fields.insert().values(**values)
        field.id = await db.execute(query)

        return field

    @classmethod
    async def get(cls, id: int, db: Session = Depends(get_db)) -> Optional['field']:
        """Get a field from the database from its id."""
        query = Fields.select().where(Fields.c.id == id)
        field = await db.fetch_one(query)
        if field:
            return field(**field)

    @classmethod
    async def get_toggle(cls, id: int, db: Session = Depends(get_db)) -> Optional['field']:
        """Get the status of a field from the database from its id."""
        query = select(Fields.c.toggle).select_from(Fields).where(Fields.c.id == id)
        toggle = await db.fetch_one(query)
        if toggle:
            return toggle

    @classmethod
    async def get_all(cls) -> list['field']:
        """Return a list of all Fields from the database."""
        return [field(**field) for field in await db.fetch_all(Fields.select())]

    @classmethod
    async def update(cls, id: int, **kwargs) -> Optional['field']:
        """Update fields of a field."""
        query = Fields.update().where(Fields.c.id == id).values(**kwargs).returning(Fields)
        if field := await db.fetch_one(query):
            return field(**field)

    @classmethod
    async def edit_toggle(cls, id: int, toggle: bool, field: 'field') -> Optional['dict']:
        """Edit toggle of a field using another field object."""
        field = field.dict()
        field.pop('id')
        field['toggle'] = toggle
        return await cls.update(id, **field)

    @classmethod
    async def edit(cls, id: int, field: 'field') -> Optional['field']:
        """Edit a field using another field object."""
        field = field.dict()
        field.pop('id')
        return await cls.update(id, **field)

    @classmethod
    async def delete(cls, id: int, db: Session = Depends(get_db)) -> Optional['field']:
        """Delete a field and return it. Return None if the field does not exists."""
        query = Fields.delete().where(Fields.c.id == id).returning(Fields)
        field = await db.fetch_one(query)

        return field
